<!doctype html>
<html lang="en">
    <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
    <link rel="stylesheet" href="css/technical documentation.css">
    <title>Technical documentation</title>
    </head>
    <body>
        <nav id="navbar" class="nav-bar">
            <header class="nav-head">JavaScript Features</header>
            <hr>
            <a href="#Imperative_and_structured" class="nav-link">Imperative and structured</a>
            <hr>
            <a href="#Weakly_typed" class="nav-link">Weakly typed</a>
            <hr>
            <a href="#Dynamic" class="nav-link">Dynamic</a>
            <hr>
            <a href="#Object-orientation_(prototype-based)" class="nav-link">Object-orientation (prototype-based)</a>
            <hr>
            <a href="#Functional" class="nav-link">Functional</a>
            <hr>
            <a href="#Reference" class="nav-link">Reference</a>
        </nav>
        <main id="main-doc" class="main">
            <h5>The following features are common to all conforming ECMAScript implementations, unless explicitly specified otherwise.</h5>
            <br>
            <hr>
            <section class="main-section" id="Imperative_and_structured">
                <header>Imperative and structured</header>
                <article>
                    <p>JavaScript supports much of the structured programming syntax from C (e.g., <code>if</code> statements, <code>while</code> loops,<code> switch</code> statements, 
                    <code>do while</code> loops, etc.). One partial exception is scoping:
                    JavaScript originally had only function scoping with <code>var</code>.
                    ECMAScript 2015 added keywords <code>let</code> and <code>const</code> for block scoping, meaning JavaScript now has both function and block scoping. 
                    Like C, JavaScript makes a distinction between expressions and statements. 
                    One syntactic difference from C is automatic semicolon insertion, which allows the semicolons that would normally terminate 
                    statements to be omitted.</p>
                </article>
            </section>
            <br>
            <hr>
            <section class="main-section" id="Weakly_typed">
                <header>Weakly typed</header>
                <article>
                    <p>JavaScript is weakly typed, which means certain types are implicitly cast depending on the operation used.</p>
                    <ul>
                        <li>The binary <code>+</code> operator casts both operands to a string unless both operands are numbers. 
                        This is because the addition operator doubles as a concatenation operator.</li>
                        <li>The binary <code>-</code> operator always casts both operands to a number.</li>
                        <li>Both unary operators (<code>+</code>, <code>-</code>)</code> always cast the operand to a number</li>
                    </ul>
                    <p>Values are cast to strings like the following:</p>
                    <ul>
                        <li>Strings are left as-is.</li>
                        <li>Numbers are converted to their string representation.</li>
                        <li></li>Arrays have their elements cast to strings after which they are joined by commas (<code>,</code>).</li>
                        <li>Other objects are converted to the string <code>[object Object]</code> where <code>Object</code> is the name of the constructor of the object.</li>
                    </ul>
                    <p>Values are cast to numbers by casting to strings and then casting the strings to numbers. These processes can be 
                    modified by defining <code>toString</code> and <code>valueOf</code> functions on the prototype for string and number casting respectively.</p>
                    <p>JavaScript has received criticism for the way it implements these conversions as the complexity of the rules 
                        can be mistaken for inconsistency. For example, when adding a number to a string, the number will be 
                        cast to a string before performing concatenation, but when subtracting a number from a string, 
                        the string is cast to a number before performing subtraction.</p>
                    <h6>JavaScript includes a number of quirks that have been subject to criticism:</h6>
                    <table>
                        <tr>
                            <th>left operand</th>
                            <th>operator</th>
                            <th>right operand</th>
                            <th>result</th>
                        </tr>
                        <tr>
                            <td><code>[]</code> (empty array)</td>
                            <td><code>+</code></td>
                            <td><code>[ ]</code> (empty array)</td>
                            <td><code>""</code> (empty string)</td>
                        </tr>
                        <tr>
                            <td><code>[ ]</code> (empty array)</td>
                            <td><code>+</code></td>
                            <td><code>{ }</code> (empty object)</td>
                            <td><code>"[object Object]"</code> (string)</td>
                        </tr>
                        <tr>
                            <td><code>false</code> (boolean)</td>
                            <td><code>+</code></td>
                            <td><code>[ ]</code> (empty array)</td>
                            <td><code>"false"</code> (string)</td>
                        </tr>
                        <tr>
                            <td><code>"123"</code>(string)</td>
                            <td><code>+</code></td>
                            <td><code>1</code> (number)</td>
                            <td><code>"1231"</code> (string)</td>
                        </tr>
                        <tr>
                            <td><code>"123"</code> (string)</td>
                            <td><code>-</code></td>
                            <td><code>1</code> (number)</td>
                            <td><code>122</code> (number)</td>
                        </tr>
                    </table>
                    <p>Often also mentioned is <code>{} + []</code> resulting in <code>0</code> (number). 
                        This is misleading: the <code>{}</code> is interpreted as an empty code block instead of an empty object, 
                        and the empty array is cast to a number by the remaining unary <code>+</code> operator. 
                        If you wrap the expression in parentheses <code>({} + [])</code> the curly brackets are interpreted as 
                        an empty object and the result of the expression is <code>"[object Object]"</code> as expected.</p>
                </article>
            </section>
            <br>
            <hr>
            <section class="main-section" id="Dynamic">
                <header>Dynamic</header>
                <article>
                    <h6>Typing</h6>
                    <p>JavaScript is dynamically typed like most other scripting languages. A type is associated with 
                        a value rather than an expression. For example, a variable initially bound to a number may be 
                        reassigned to a string. JavaScript supports various ways to test the type of objects, 
                        including duck typing.</p>
                    <h6>Run-time evaluation</h6>
                    <p>JavaScript includes an <code>eval</code> function that can execute statements provided as strings at run-time.</p>
                </article>
            </section>
            <br>
            <hr>
            <section class="main-section" id="Object-orientation_(prototype-based)">
                <header>Object-orientation (prototype-based)</header>
                <article>
                    <p>Prototypal inheritance in JavaScript is described by Douglas Crockford as:</p>
                    <blockquote>
                            You make prototype objects, and then … make new instances. Objects are mutable in JavaScript, 
                            so we can augment the new instances, giving them new fields and methods. 
                            These can then act as prototypes for even newer objects. We don't need classes to make lots of similar objects… 
                            Objects inherit from objects. What could be more object oriented than that?
                    </blockquote>
                    <p>In JavaScript, an object is an associative array, augmented with a prototype (see below); 
                            each string key provides the name for an object property, and there are two syntactical 
                            ways to specify such a name: dot notation <code>(obj.x = 10)</code> and bracket notation <code>(obj['x'] = 10)</code>. 
                            A property may be added, rebound, or deleted at run-time. Most properties of an object 
                            (and any property that belongs to an object's prototype inheritance chain) can be enumerated using a <code>for...in</code> loop.</p>
                    <h6>Prototypes</h6>
                    <p>JavaScript uses prototypes where many other object-oriented languages use classes for inheritance. 
                            It is possible to simulate many class-based features with prototypes in JavaScript.</p>
                    <h6>Functions as object constructors</h6>
                    <p>Functions double as object constructors, along with their typical role. 
                            Prefixing a function call with new will create an instance of a prototype, 
                            inheriting properties and methods from the constructor (including properties from the <code>Object</code> prototype).
                            ECMAScript 5 offers the <code>Object.create</code> method, allowing explicit creation of an instance without 
                            automatically inheriting from the <code>Object</code> prototype (older environments can assign the prototype to <code>null</code>). T
                            he constructor's <code>prototype</code> property determines the object used for the new object's internal prototype. 
                            New methods can be added by modifying the prototype of the function used as a constructor. 
                            JavaScript's built-in constructors, such as <code>Array</code> or <code>Object</code>, also have prototypes that can be modified. 
                            While it is possible to modify the <code>Object</code> prototype, it is generally considered bad practice 
                            because most objects in JavaScript will inherit methods and properties from the <code>Object</code> prototype, 
                            and they may not expect the prototype to be modified.</p>
                    <h6>Functions as methods</h6>
                    <p>Unlike many object-oriented languages, there is no distinction between a function 
                            definition and a method definition. Rather, the distinction occurs during function calling; 
                            when a function is called as a method of an object, the function's local <code>this</code> keyword is 
                            bound to that object for that invocation.</p>
                </article>
            </section>
            <br>
            <hr>
            <section class="main-section" id="Functional">
                <header>Functional</header>
                <article>
                        A function is first-class; a function is considered to be an object. As such, 
                        a function may have properties and methods, such as <code>.call()</code> and <code>.bind()</code>. 
                        A nested function is a function defined within another function. 
                        It is created each time the outer function is invoked. In addition, 
                        each nested function forms a lexical closure: The lexical scope of the outer function 
                        (including any constant, local variable, or argument value) becomes part of the internal 
                        state of each inner function object, even after execution of the outer function concludes. 
                        JavaScript also supports anonymous functions.
                </article>
            </section>
            <br>
            <hr>
            <section class="main-section" id="Reference">
                <header>Reference</header>
                <article>
                    <ul>
                        <li>All the documentation in this page is taken from <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank">Wikipedia</a></li>
                    </ul>
                </article>
            </section>
        </main>
    <!-- Optional JavaScript; choose one of the two! -->

    <!-- Option 1: Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" crossorigin="anonymous"></script>

    <!-- Option 2: Separate Popper and Bootstrap JS -->
    <!--
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js" integrity="sha384-q2kxQ16AaE6UbzuKqyBE9/u/KzioAlnx2maXQHiDX9d4/zp8Ok3f+M7DPm+Ib6IU" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.min.js" integrity="sha384-pQQkAEnwaBkjpqZ8RU1fF1AKtTcHJwFl3pblpTlHXybJjHpMYo79HY3hIi4NKxyj" crossorigin="anonymous"></script>
    -->
  </body>
</html>